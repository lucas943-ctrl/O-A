1) Esqueleto genérico (4 tabelas)

Suponha 4 tabelas: clientes, pedidos, itens_pedido, produtos.

Chaves (exemplo)

clientes(cliente_id PK)

pedidos(pedido_id PK, cliente_id FK)

itens_pedido(item_id PK, pedido_id FK, produto_id FK)

produtos(produto_id PK)

Objetivo

Trazer 1 linha por item, com dados do cliente, do pedido e do produto.

-- Funciona em PostgreSQL/MySQL/SQL Server (com mínimas adaptações)
WITH pedidos_validos AS (
  SELECT p.pedido_id, p.cliente_id, p.data_pedido, p.status
  FROM pedidos p
  WHERE p.status IN ('APROVADO','FATURADO')         -- (1) filtragem inicial
),
itens_enriquecidos AS (
  SELECT i.item_id, i.pedido_id, i.produto_id, i.qtd, i.preco_unit
  FROM itens_pedido i
  WHERE i.qtd > 0                                    -- (2) saneamento simples
)
SELECT
  c.cliente_id,
  c.nome AS cliente_nome,
  pv.pedido_id,
  pv.data_pedido,
  pv.status AS status_pedido,
  ie.item_id,
  ie.qtd,
  ie.preco_unit,
  pr.produto_id,
  pr.nome AS produto_nome,
  pr.categoria
FROM pedidos_validos pv
JOIN clientes c             ON c.cliente_id  = pv.cliente_id      -- (3) JOIN 1
JOIN itens_enriquecidos ie  ON ie.pedido_id  = pv.pedido_id        -- (4) JOIN 2
LEFT JOIN produtos pr       ON pr.produto_id = ie.produto_id       -- (5) JOIN 3 (LEFT para não perder item sem cadastro)
;


Por que usar CTEs (WITH)?
Você separa a limpeza/filtragem por etapas, deixa o SQL legível e facilita manutenção.

2) Variações rápidas de JOIN

INNER JOIN: mantém apenas correspondências entre as tabelas (mais “restritivo”).

LEFT JOIN: mantém tudo da tabela da esquerda e coloca NULL onde não houver correspondência.

RIGHT/FULL JOIN: menos comuns; FULL traz tudo de ambos os lados (nem todo SGBD tem).

CROSS JOIN: produto cartesiano (use com cuidado).

Exemplo trocando ordens/estratégias:

-- Manter todos os pedidos, mesmo sem itens ainda (LEFT no itens)
SELECT *
FROM pedidos p
LEFT JOIN itens_pedido i ON i.pedido_id = p.pedido_id
LEFT JOIN produtos pr    ON pr.produto_id = i.produto_id
LEFT JOIN clientes c     ON c.cliente_id = p.cliente_id;

3) Esqueleto “universal” com padronização de chaves/tipos

Às vezes chaves vêm em tipos/formatos diferentes. Padronize antes.

WITH norm_clientes AS (
  SELECT CAST(cliente_id AS BIGINT) AS cliente_id, UPPER(TRIM(nome)) AS nome
  FROM clientes
),
norm_pedidos AS (
  SELECT CAST(pedido_id AS BIGINT) AS pedido_id,
         CAST(cliente_id AS BIGINT) AS cliente_id,
         CAST(data_pedido AS DATE)  AS data_pedido,
         UPPER(status) AS status
  FROM pedidos
),
norm_itens AS (
  SELECT CAST(item_id AS BIGINT) AS item_id,
         CAST(pedido_id AS BIGINT) AS pedido_id,
         CAST(produto_id AS BIGINT) AS produto_id,
         qtd, preco_unit
  FROM itens_pedido
),
norm_produtos AS (
  SELECT CAST(produto_id AS BIGINT) AS produto_id,
         UPPER(TRIM(nome)) AS nome, UPPER(TRIM(categoria)) AS categoria
  FROM produtos
)
SELECT *
FROM norm_pedidos p
JOIN norm_clientes c ON c.cliente_id = p.cliente_id
JOIN norm_itens i    ON i.pedido_id  = p.pedido_id
LEFT JOIN norm_produtos pr ON pr.produto_id = i.produto_id;

4) Esqueleto com agregação (ex.: total por pedido)
WITH itens_agg AS (
  SELECT
    i.pedido_id,
    SUM(i.qtd * i.preco_unit) AS valor_pedido,
    COUNT(*) AS qtd_itens
  FROM itens_pedido i
  GROUP BY i.pedido_id
)
SELECT
  p.pedido_id,
  c.nome AS cliente,
  p.data_pedido,
  ia.qtd_itens,
  ia.valor_pedido
FROM pedidos p
JOIN clientes c ON c.cliente_id = p.cliente_id
LEFT JOIN itens_agg ia ON ia.pedido_id = p.pedido_id;

5) “Checklist” de integração (tutorial resumido)

Mapeie as chaves: quem referencia quem (PK ↔︎ FK).

Garanta tipos compatíveis nas chaves (ex.: INT com INT, evite VARCHAR vs INT).

Faça saneamento: TRIM, UPPER/LOWER, remoção de duplicados, datas válidas.

Separe em camadas:

staging (dados crus normalizados),

refined (regras de negócio, filtros),

mart/view final (tabela para consumo).

Escolha os JOINs:

Se não pode perder registros “base”, use LEFT a partir dela.

Se só quer correspondências válidas, use INNER.

Valide faltantes (anti-join):

-- Clientes que têm pedidos sem cliente correspondente (deveria ser 0)
SELECT p.cliente_id
FROM pedidos p
LEFT JOIN clientes c ON c.cliente_id = p.cliente_id
WHERE c.cliente_id IS NULL;


Crie índices nas colunas de junção e filtros principais.

Materialize em VIEW ou tabela física se for consumo frequente.

Monitore volumes, planos de execução e nulos inesperados.

6) Índices (performance)
-- PostgreSQL / MySQL
CREATE INDEX idx_pedidos_cliente_id ON pedidos(cliente_id);
CREATE INDEX idx_itens_pedido_id    ON itens_pedido(pedido_id);
CREATE INDEX idx_itens_produto_id   ON itens_pedido(produto_id);
CREATE INDEX idx_produtos_produto_id ON produtos(produto_id);

-- SQL Server
CREATE INDEX idx_pedidos_cliente_id ON dbo.pedidos(cliente_id);


Dica: sempre indexe as colunas usadas em ON e nos WHERE de alto seletividade.

7) Esqueleto por SGBD (pequenas diferenças)
PostgreSQL

Usa aspas " para identificadores. USING é bem-vindo quando a coluna tem o mesmo nome nas duas tabelas.

SELECT *
FROM pedidos
JOIN clientes USING (cliente_id)
JOIN itens_pedido USING (pedido_id)
LEFT JOIN produtos USING (produto_id);

MySQL

Mesma ideia; evite USING se preferir clareza com ON.

SELECT *
FROM pedidos p
JOIN clientes c     ON c.cliente_id = p.cliente_id
JOIN itens_pedido i ON i.pedido_id  = p.pedido_id
LEFT JOIN produtos pr ON pr.produto_id = i.produto_id;

SQL Server

Use schema (geralmente dbo.) e GETDATE() para data atual.

SELECT *
FROM dbo.pedidos p
JOIN dbo.clientes c     ON c.cliente_id = p.cliente_id
JOIN dbo.itens_pedido i ON i.pedido_id  = p.pedido_id
LEFT JOIN dbo.produtos pr ON pr.produto_id = i.produto_id;

8) Integração “de verdade” (entregáveis)
a) Criar uma VIEW de consumo
CREATE OR REPLACE VIEW vw_pedidos_itens AS
WITH pv AS (
  SELECT p.*
  FROM pedidos p
  WHERE p.status IN ('APROVADO','FATURADO')
)
SELECT
  c.cliente_id, c.nome AS cliente_nome,
  p.pedido_id, p.data_pedido, p.status,
  i.item_id, i.qtd, i.preco_unit,
  pr.produto_id, pr.nome AS produto_nome, pr.categoria
FROM pv p
JOIN clientes c ON c.cliente_id = p.cliente_id
JOIN itens_pedido i ON i.pedido_id = p.pedido_id
LEFT JOIN produtos pr ON pr.produto_id = i.produto_id;

b) Materializar em tabela (ETL simples)
-- staging -> refined -> final
CREATE TABLE IF NOT EXISTS fato_pedidos_itens AS
SELECT * FROM vw_pedidos_itens;

-- Depois, no seu job de integração (Airflow/cron/SQL Agent), rode:
TRUNCATE TABLE fato_pedidos_itens;
INSERT INTO fato_pedidos_itens
SELECT * FROM vw_pedidos_itens;

9) Casos especiais (dicas rápidas)

N:N com tabela ponte (ex.: produtos ↔︎ tags via produto_tag(produto_id, tag_id)):

SELECT pr.produto_id, pr.nome, t.nome AS tag
FROM produtos pr
JOIN produto_tag pt ON pt.produto_id = pr.produto_id
JOIN tags t         ON t.tag_id      = pt.tag_id;


Normalizar datas/timezones: use ::date (Postgres), DATE() (MySQL), CAST(... AS date) (SQL Server).

Null safety: COALESCE para valores padrão:

COALESCE(pr.categoria, 'SEM_CATEGORIA') AS categoria


Duplicatas: use DISTINCT com cuidado; prefira corrigir a origem.